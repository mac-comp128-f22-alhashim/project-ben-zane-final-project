Each Tile will have a numeric ID, called Order. While the location and sequence of the tiles on the board will be random, the numeric ID will not--it will always increment by 1 for each newly created tile.

The generated sequence, called genSeq, will be stored in a Queue.

We will also have an ArrayList that is a copy of genSeq, called userSeq. It will be filled with the Order of each tile in the sequence.

When the user clicks on a tile, we get that tile's Order. 

If the Order is equivalent to the Order of the first tile in the Queue (dequeue), then the user has picked the correct tile and we can continue. 

If the Order is not equivalent to the Order of the first tile in the Queue (dequeue), then the user has not picked the correct tile and we will either end the game or subtract a life and force the user to start over.

PSEUDOCODE (kinda)

Class Tile {
    Public Integer ORDER

    Public Integer GET_ORDER(Tile Target) {
        RETURN Target.ORDER
    }

    // Other existing methods to implement Tile not shown here
}

Class Game {
    // USER_SEQUENCE and ADD_TO_ARRAY are not used here because in writing the pseudocode it turns out we might not need it, but I'm keeping it in anyway in case.

    ArrayList USER_SEQUENCE -> new ArrayList
    Queue SEQUENCE -> new Queue
    
    Private void GENERATE_SEQUENCE() {
        Tile RANDOM_TILE -> new Tile

        // Existing implementation

        SEQUENCE.enqueue(RANDOM_TILE.ORDER)
    }

    Private Void ADD_TO_ARRAY() {
        For each Integer i in SEQUENCE {
            USER_SEQUENCE.add(i)
        }
    }

    Private Void CLICKING() {
        ON_CLICK(MOUSE -> {
            Tile CLICKED -> CANVAS.ELEMENT_AT(MOUSE)

            If CLICKED.ORDER Equals SEQUENCE.GET_FIRST {
                SEQUENCE.REMOVE_FIRST()
            } Else {
                END_GAME()
            }
        })
    }

    // Other existing methods to implement Game not shown here
}